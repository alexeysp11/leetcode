# mvcc 

**Multiversion concurrency control (MVCC)** - это механизм контроля параллельного доступа к данным в базе данных, который позволяет не блокировать записи при одновременном доступе нескольких транзакций к одним и тем же данным. 

Бэкэнд-разработчик должен знать о MVCC, так как это важный механизм для обеспечения производительности и целостности данных в многопользовательской среде.

## Реализация

Обычно MVCC реализуется путем создания нескольких версий каждой записи в базе данных. Каждая версия содержит информацию о времени ее создания и изменения, а также ссылки на предыдущие и последующие версии. При чтении данных транзакция получает последнюю версию записи, которая была создана до начала транзакции. При записи данных транзакция создает новую версию записи, которая становится последней версией для всех последующих транзакций.

### PostgreSQL

Реализация MVCC в PostgreSQL отличается от реализаций в других БД тем, что PostgreSQL поддерживает сериализуемые транзакции, которые гарантируют, что результат выполнения нескольких транзакций будет таким же, как если бы они выполнялись последовательно. Это достигается за счет использования алгоритма двухфазной блокировки и контроля конфликтов.

В PostgreSQL каждая версия записи хранится в специальной области памяти, называемой буфером. Буферы содержат копии страниц таблиц, которые были изменены транзакциями, и могут содержать несколько версий одной и той же страницы. Каждая версия записи содержит информацию о времени ее создания и изменения, а также ссылки на предыдущие и последующие версии.

В PostgreSQL версии хранятся в виде специальных структур данных, называемых tuple. Tuple представляют собой набор значений полей записи, а также дополнительную информацию о версии, такую как номер транзакции, время создания и изменения.

Частота создания версий в базе данных для реализации MVCC зависит от того, как часто изменяются данные в таблицах. В PostgreSQL версии создаются автоматически при каждом изменении записи в таблице.

Удаление версий, которые были созданы очень давно и уже не используются, происходит автоматически при выполнении процесса очистки. В PostgreSQL процесс очистки запускается автоматически при достижении определенного порога занятости буферов и может удалять версии, которые не используются более определенного времени.

### SQLite

В SQLite также есть реализация MVCC. Однако, в отличие от PostgreSQL, SQLite не поддерживает сериализуемые транзакции, а только чтение-коммит и чтение-изменение-коммит. Это значит, что SQLite может допустить некоторые аномалии в работе с данными при выполнении параллельных транзакций.

## Механизмы MVCC

В целом бэкэнд-разработчик должен иметь понимание того, как работают механизмы параллельного доступа к данным в базах данных и как это может повлиять на производительность и целостность данных. Также может потребоваться знание конкретных реализаций MVCC в популярных БД, таких как PostgreSQL, MySQL и MS SQL.

Механизмы параллельного доступа к данным в базах данных позволяют нескольким пользователям одновременно работать с одной и той же базой данных. Это может повлиять на производительность и целостность данных, так как при параллельном доступе возникают проблемы с блокировками, конфликтами и несогласованностью данных. Некорректная работа с механизмами параллельного доступа может привести к ошибкам в работе базы данных, потере данных или нарушению их целостности.

## Практические задачи 

### Страницы

1. Создайте таблицу и вставьте в нее одну строку. Затем дважды обновите эту строку и удалите ее. Сколько версий строк находится сейчас в таблице? Проверьте, используя расширение pageinspect.
2. Определите, в какой странице находится строка таблицы pg_class. Сколько актуальных версий строк находится в той же странице?
3. Включите в psql параметр `on_error_rollback` и убедитесь, что этот режим использует вложенные транзакции.

### Снимки данных

1. Воспроизведите ситуацию, при которой одна транзакция ещё видит удалённую строку, а другая - уже нет. Посмотрите снимки данных этих транзакций и значения полей xmin и xmax удалённой строки. Объясните видимость на основании этих данных.
2. Если в запросе вызывается функция, содержащая другой запрос, какой снимок данных будет использоваться для "вложенного" запроса? Проверьте уровни изоляции `read commited` и `repeatable read` и категории изменчивости функций `volatile` и `stable`.
3. В одной транзакции экпортируйте снимок, затем в другой транзакции измените данные. Импортируйте снимок и проверьте, что в нем видны ещё не измененные данные.
