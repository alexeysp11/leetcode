# isolationlevels

В PostgreSQL уровни изоляции устанавливаются на уровне транзакции. Нельзя установить уровень изоляции на уровне таблицы или представления.

## Теория 

### Isolation levels

#### READ COMMITTED

Транзакция может видеть только строки, зафиксированные до её начала. 
Этот уровень изоляции является по умолчанию.

Основные отличительные особенности уровня изоляции READ COMMITTED в PostgreSQL заключаются в том, что каждая новая команда SELECT видит только изменения, сделанные в рамках текущей транзакции, и изменения, сделанные другими транзакциями, только после их фиксации. 
Это означает, что данные могут быть изменены другими транзакциями между командами SELECT в рамках одной транзакции.

#### REPEATABLE READ

Уровень изоляции REPEATABLE READ гарантирует, что данные, прочитанные в рамках транзакции, не будут изменены другими транзакциями до её завершения. 

Это достагается с помощью механизма блокировки доступа к этим данным для других транзакций. 
Для этого используется механизм блокировки строк, который позволяет избежать "грязного чтения" и "неповторяемого чтения".

#### SERIALIZABLE

Уровень изоляции SERIALIZABLE гарантирует, что транзакции будут выполнены так, как если бы они были выполнены последовательно, без пересечения. Это означает, что если две транзакции пытаются изменить одни и те же данные одновременно, одна из них будет отменена с ошибкой сериализации.

В оффициальной документации PostgreSQL при определении уровня изоляции SERIALIZABLE сказано следующее: "Если шаблон чтения и записи среди одновременных сериализуемых транзакций создаст ситуацию, которая не могла бы возникнуть при последовательном (поочередном) выполнении этих транзакций, одна из них будет отменена с ошибкой сериализации". 

Примером ситуации, которая не могла бы возникнуть при последовательном выполнении транзакций, является "фантомное чтение". Например, если транзакция A выполняет SELECT с условием WHERE на некоторую таблицу, а затем транзакция B вставляет новую строку в эту таблицу, которая удовлетворяет условию WHERE, то если обе транзакции выполняются параллельно с уровнем изоляции SERIALIZABLE, то транзакция A будет отменена с ошибкой сериализации.

### Проблема "фантомное чтение"

Если "фантомное чтение" произойдёт, когда две транзакции имеют уровень изоляции REPEATABLE READ или READ COMMITTED, то одна из них будет заблокирована до завершения другой транзакции, чтобы избежать конфликтов при изменении данных.

Если "фантомное чтение" произойдёт, когда одна транзакция имеет уровень изоляции SERIALIZABLE, а вторая - REPEATABLE READ или READ COMMITTED, то транзакция с более высоким уровнем изоляции будет отменена с ошибкой сериализации.

Если "фантомное чтение" произойдёт, когда одна транзакция имеет уровень изоляции REPEATABLE READ, а вторая - READ COMMITTED, то транзакция с уровнем изоляции REPEATABLE READ будет заблокирована до завершения другой транзакции.

### Резервное копирование 

#### SNAPSHOT

SNAPSHOT в PostgreSQL - это точка во времени, на которую можно ссылаться для чтения данных, как если бы они были прочитаны в этот момент времени. Это позволяет избежать блокировок и конфликтов при чтении данных в рамках транзакции.

SNAPSHOT может быть использован для осуществления уровней изоляции. 
Например, установка уровня изоляции REPEATABLE READ с использованием SNAPSHOT позволяет гарантировать, что данные, прочитанные в рамках транзакции, не будут изменены другими транзакциями до её завершения.

SNAPSHOT в PostgreSQL позволяет ссылаться на состояние базы данных на определенный момент времени за счёт механизма многоверсионности (MVCC). 
Каждая транзакция работает с версией данных, которая была актуальна на момент её начала, и не видит изменений, сделанных другими транзакциями после этого момента.

#### SQL Dump

SQL Dump в PostgreSQL - это файл, содержащий SQL-команды для создания и заполнения базы данных. Он используется для резервного копирования и восстановления базы данных. 

Отличие от SNAPSHOT заключается в том, что SQL Dump сохраняет состояние базы данных на момент создания дампа, а SNAPSHOT позволяет ссылаться на состояние базы данных на определенный момент времени.

## Практические задачи 

**Дано**: 
- Есть две транзакции и две таблицы в БД. 
- *Транзакция А* взаимодействует с таблицами А и B (стрелочки A и B), *транзакция B* - только с таблицей B (стрелочка C). 

![databases.isolationlevels](../../img/databases.isolationlevels.png)

**Последовательность взаимодействия**: 
- *транзакция А* читает данные из таблицы B по ИД от 24 по 78 (стрелочка B), 
- *транзакция B* изменяет данные таблицы B по ИД с 12 до 20 и коммитит изменения (стрелочка C), 
- *транзакция А* читает данные из таблицы B по ИД от 3 до 15 (стрелочка B). 

**Возможные изменения в последовательности взаимодействия**: 
- *транзакция B* изменяет данные таблицы B по ИД с 12 до 34 и коммитит изменения (стрелочка C).
- Опционально: *транзакция B* не выполнила коммит изменений (например, *транзакция А* раньше прочитала данные, или разработчик забыл поставить комманду `COMMIT`). 

**Вопросы**:

Нужно ответить, как будут вести себя транзакции (увидит ли *транзакция А* новые данные, сможет ли *транзакция B* изменить данные, заблокируется ли *таблица B* и т.д.) при следующих условиях: 
1. Обе транзакции имеют уровень изоляции `READ COMMITTED`. 
2. Обе транзакции имеют уровень изоляции `REPEATABLE READ`.
3. Обе транзакции имеют уровень изоляции `SERIALIZABLE`.
4. Транзакция А имеет уровень изоляции `REPEATABLE READ`, а транзакция B - `READ COMMITTED`. Что изменится, если транзакции поменяются уровнями изоляции (транзакция А - `READ COMMITTED`, а транзакция B - `REPEATABLE READ`)? 
5. Транзакция А имеет уровень изоляции `SERIALIZABLE`, а транзакция B - `READ COMMITTED`. Что изменится, если транзакции поменяются уровнями изоляции (транзакция А - `READ COMMITTED`, а транзакция B - `SERIALIZABLE`)? 
6. Транзакция А имеет уровень изоляции `REPEATABLE READ`, а транзакция B - `SERIALIZABLE`. Что изменится, если транзакции поменяются уровнями изоляции (транзакция А - `SERIALIZABLE`, а транзакция B - `REPEATABLE READ`)? 
